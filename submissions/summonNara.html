/*       _..---.--.
       .'\ __|/O.__)
      /__.' _/ .-'_\
     (____.'.-_\____)
      (_/ _)__(_ \_ )_
    mrf(_..)--(.._)'--'

    if you're looking at this page to learn about coding,
    you can ask chuwigirls for help!

==============================
===== Summoning New Nara =====
============================== */
const CLOUDINARY_CLOUD_NAME = "NarasNature"; // e.g. "naranature"
const CLOUDINARY_UPLOAD_PRESET = "NarasNature"; // your unsigned preset name
const SUMMONS_URL = SCRIPT_URL_SUMMONS;
const FEATURES_URL = "https://opensheet.elk.sh/1lGc4CVqcFr9LtcyVW-78N5En7_imdfC8bTf6PRUD-Ms/Features";
const OPTIONS_URL  = "https://opensheet.elk.sh/1lGc4CVqcFr9LtcyVW-78N5En7_imdfC8bTf6PRUD-Ms/Options";
const ARTIFACTS_URL  = "https://opensheet.elk.sh/1lGc4CVqcFr9LtcyVW-78N5En7_imdfC8bTf6PRUD-Ms/Artifacts";

// ==============================
// Generic loader
// ==============================
async function loadSheetOptions(selectId, category, isMulti = false, sheet = "features") {
  try {
    let url;
    if (sheet === "options") url = OPTIONS_URL;
    else if (sheet === "artifacts") url = ARTIFACTS_URL;
    else url = FEATURES_URL;

    const res = await fetch(url);
    const rows = await res.json();
    if (!Array.isArray(rows)) {
      console.warn(`Expected rows array from ${url} but got:`, rows);
      return;
    }

    const fieldName = sheet === "options" ? "Option" : (sheet === "artifacts" ? "Artifact" : "Feature");
    const norm = v => (v === undefined || v === null) ? "" : String(v).trim().toLowerCase();

    let filteredRows = [];
    if (sheet === "artifacts") {
      const allArtifacts = rows.filter(r => {
        const st = norm(r.Subtype);
        return st === "design artifact" || st === "feature artifact";
      });

      const discordUser = JSON.parse(localStorage.getItem("discordUser") || "{}");
      const discordId = discordUser?.id?.toString?.().trim?.();

      if (discordId) {
        try {
          const troveURL = "https://opensheet.elk.sh/1FGsqhNZ_fYW-njhJlP39r-nQeK2X4FCIXeC_FTeU6lM/Inventory";
          const invRes = await fetch(troveURL);
          if (!invRes.ok) throw new Error(`Bad response: ${invRes.status}`);
          const invRows = await invRes.json();
          if (!Array.isArray(invRows)) throw new Error("Inventory data not array");

          const userRow = invRows.find(r => {
            const idCell = (r["Discord ID"] || r["discord id"] || r["DiscordID"] || "").toString().trim();
            return idCell === discordId;
          });

          if (userRow) {
            const ownedArtifacts = Object.entries(userRow)
              .filter(([key, val]) => {
                const keyNorm = key.toString().trim();
                if (!keyNorm) return false;
                if (["Civilian", "Discord ID", "discord id", "Civilian Name"].includes(keyNorm)) return false;
                return Number(val) > 0;
              })
              .map(([key]) => norm(key));

            if (ownedArtifacts.length) {
              filteredRows = allArtifacts.filter(a => ownedArtifacts.includes(norm(a.Artifact)));
            } else {
              filteredRows = [];
              console.warn("⚠️ User owns no Design/Feature Artifacts.");
            }
          } else {
            filteredRows = [];
            console.warn("⚠️ User not found in Inventory (Nara Trove).");
          }
        } catch (err) {
          console.error("Error loading Inventory; falling back to all artifacts:", err);
          filteredRows = allArtifacts.slice();
        }
      } else {
        console.warn("⚠️ No Discord user logged in; showing all artifacts.");
        filteredRows = allArtifacts.slice();
      }

    } else {
      const filterField = rows.length && rows[0].Type ? "Type" : "Category";
      filteredRows = rows.filter(r => norm(r[filterField]) === category.toLowerCase());
    }

    const container = document.getElementById(selectId);
    if (!container) {
      console.warn(`❌ No container with id ${selectId}`);
      return;
    }

    container.innerHTML = "";

    if (!filteredRows || filteredRows.length === 0) {
      if (sheet === "artifacts") {
        const select = document.createElement("select");
        select.name = category;
        select.required = true;
        select.classList.add("dynamic-select");

        const blank = document.createElement("option");
        blank.value = "";
        blank.textContent = `-- Select ${category} --`;
        select.appendChild(blank);

        const noOpt = document.createElement("option");
        noOpt.disabled = true;
        noOpt.selected = true;
        noOpt.textContent = "No Design/Feature Artifacts in your inventory";
        select.appendChild(noOpt);

        container.appendChild(select);
        return;
      } else {
        return;
      }
    }

    const hasSubtype = filteredRows.some(r => (r.Subtype || "").toString().trim() !== "");
    const grouped = {};
    if (hasSubtype) {
      filteredRows.forEach(r => {
        const g = (r.Subtype || "Other").toString().trim() || "Other";
        if (!grouped[g]) grouped[g] = [];
        const label = r[fieldName];
        if (label) grouped[g].push(label);
      });
    }

    if (!isMulti) {
      const select = document.createElement("select");
      select.name = category;
      select.required = true;
      select.classList.add("dynamic-select");

      const blank = document.createElement("option");
      blank.value = "";
      blank.textContent = `-- Select ${category} --`;
      select.appendChild(blank);

      if (hasSubtype) {
        for (const [group, items] of Object.entries(grouped)) {
          const optgroup = document.createElement("optgroup");
          optgroup.label = group;
          items.forEach(v => {
            const opt = document.createElement("option");
            opt.value = v;
            opt.textContent = v;
            optgroup.appendChild(opt);
          });
          select.appendChild(optgroup);
        }
      } else {
        filteredRows.forEach(r => {
          const opt = document.createElement("option");
          opt.value = r[fieldName];
          opt.textContent = r[fieldName];
          select.appendChild(opt);
        });
      }

      container.appendChild(select);
      return;
    }

    function createGroupedSelect() {
      const existingAddBtn = container.querySelector(".add-btn");
      if (existingAddBtn) existingAddBtn.remove();

      const wrapper = document.createElement("div");
      wrapper.classList.add("dropdown-wrapper");

      const selectEl = document.createElement("select");
      selectEl.name = `${category}[]`;
      selectEl.classList.add("dynamic-select");
      if (container.querySelectorAll(".dropdown-wrapper").length === 0) selectEl.required = true;

      const blank = document.createElement("option");
      blank.value = "";
      blank.textContent = "-- Select --";
      selectEl.appendChild(blank);

      if (hasSubtype) {
        for (const [group, items] of Object.entries(grouped)) {
          const optgroup = document.createElement("optgroup");
          optgroup.label = group;
          items.forEach(v => {
            const opt = document.createElement("option");
            opt.value = v;
            opt.textContent = v;
            optgroup.appendChild(opt);
          });
          selectEl.appendChild(optgroup);
        }
      } else {
        filteredRows.forEach(r => {
          const opt = document.createElement("option");
          opt.value = r[fieldName];
          opt.textContent = r[fieldName];
          selectEl.appendChild(opt);
        });
      }

      let removeBtn = null;
      if (container.querySelectorAll(".dropdown-wrapper").length > 0) {
        removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.textContent = "×";
        removeBtn.classList.add("remove-btn");
        removeBtn.addEventListener("click", () => {
          container.removeChild(wrapper);
          updateAddButton();
        });
      }

      wrapper.appendChild(selectEl);
      if (removeBtn) wrapper.appendChild(removeBtn);
      container.appendChild(wrapper);

      selectEl.addEventListener("change", () => updateAddButton());
      updateAddButton();
    }

    function updateAddButton() {
      const existingAddBtn = container.querySelector(".add-btn");
      if (existingAddBtn) existingAddBtn.remove();

      const selects = container.querySelectorAll("select.dynamic-select");
      const lastSelect = selects[selects.length - 1];
      if (selects.length >= 5) return;
      if (!lastSelect || !lastSelect.value) return;

      const addBtn = document.createElement("button");
      addBtn.type = "button";
      addBtn.textContent = "+";
      addBtn.classList.add("add-btn");
      addBtn.addEventListener("click", createGroupedSelect);
      container.appendChild(addBtn);
    }

    createGroupedSelect();

  } catch (err) {
    console.error(`Error loading ${category} from ${sheet}:`, err);
  }
}

// ==============================
// DOM Ready
// ==============================
document.addEventListener("DOMContentLoaded", () => {
  const dropdowns = [
    { id: "stageSelect", category: "Stage", multi: false, sheet: "options" },
    { id: "artifactSelect", category: "Artifacts", multi: true, sheet: "artifacts" },
    { id: "buildSelect", category: "Build", multi: false, sheet: "features" },
    { id: "vesselSelect", category: "Vessel", multi: true, sheet: "features" },
    { id: "ribbonsSelect", category: "Ribbons", multi: true, sheet: "features" },
    { id: "tailSelect", category: "Tail", multi: true, sheet: "features" },
    { id: "physiognomySelect", category: "Physiognomy", multi: true, sheet: "features" },
    { id: "aestheticsSelect", category: "Aesthetics", multi: true, sheet: "features" }
  ];

  dropdowns.forEach(d => loadSheetOptions(d.id, d.category, d.multi, d.sheet));

  const form = document.getElementById("naraForm");
  form.addEventListener("submit", handleFormSubmit);
});

// ==============================
// Image Preview Handler
// ==============================
document.addEventListener("change", e => {
  if (e.target.id === "imageFile") {
    const fileInput = e.target;
    const previewContainer = document.getElementById("imagePreviewContainer");
    const previewImg = document.getElementById("imagePreview");

    if (fileInput.files && fileInput.files[0]) {
      const reader = new FileReader();
      reader.onload = function(ev) {
        previewImg.src = ev.target.result;
        previewContainer.style.display = "block";
      };
      reader.readAsDataURL(fileInput.files[0]);
    } else {
      previewContainer.style.display = "none";
      previewImg.src = "";
    }
  }
});

// ==============================
// Form Submit Handler
// ==============================
async function handleFormSubmit(e) {
  e.preventDefault();

  const statusMsg = document.getElementById("statusMsg");
  statusMsg.textContent = "Submitting Summon...";

  const user = JSON.parse(localStorage.getItem("discordUser"));
  if (!user) {
    alert("You must be logged in to submit a Summon.");
    statusMsg.textContent = "Login required.";
    return;
  }

  const username = user.username;
  const discordId = user.id;

  const fileInput = document.getElementById("imageFile");
  let imageUrl = "";

  if (fileInput.files.length > 0) {
    const file = fileInput.files[0];
    uploadStatus.textContent = "Uploading image...";

    const formData = new FormData();
    formData.append("file", file);
    formData.append("upload_preset", CLOUDINARY_UPLOAD_PRESET);

    try {
      const cloudRes = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`, {
        method: "POST",
        body: formData
      });

      const cloudData = await cloudRes.json();

      if (!cloudRes.ok || !cloudData.secure_url) {
        throw new Error(cloudData.error?.message || "Upload failed.");
      }

      imageUrl = cloudData.secure_url;
      uploadStatus.textContent = "✅ Image uploaded successfully!";
      console.log("Uploaded to Cloudinary:", imageUrl);

    } catch (err) {
      console.error("Cloudinary upload error:", err);
      uploadStatus.textContent = "❌ Upload failed: " + err.message;
      statusMsg.textContent = "❌ Summon cancelled due to upload error.";
      return;
    }
  } else {
    alert("Please upload an image before submitting.");
    statusMsg.textContent = "Image required.";
    return;
  }

  const form = e.target;
  const now = new Date();
  const timestampISO = now.toISOString();
  const timestampEpoch = now.getTime().toString();

  function collectMulti(name) {
    return [...form.querySelectorAll(`select[name="${name}[]"]`)]
      .map(s => s.value)
      .filter(v => v)
      .join(", ");
  }

  const payload = {
    type: "summonNara",
    Timestamp: timestampISO,
    TimestampEpoch: timestampEpoch,
    Comments: "",
    Hide: "",
    URL: imageUrl,
    Art: "",
    Stage: form.querySelector("select[name='Stage']")?.value || "",
    Artifacts: collectMulti("Artifacts"),
    Owner: username || form.Owner.value,
    "Discord ID": discordId, 
    Designer: form.Designer.value,
    Artist: form.Artist.value,
    Status: "Pending",
    Rarity: "",
    Region: "",
    Calling: "",
    Value: "",
    Build: form.querySelector("select[name='Build']")?.value || "",
    Inventory: "",
    Palcharms: "",
    Emblems: "",
    Titles: "",
    Guild: "",
    Vessel: collectMulti("Vessel"),
    Ribbons: collectMulti("Ribbons"),
    Tail: collectMulti("Tail"),
    Physiognomy: collectMulti("Physiognomy"),
    Aesthetics: collectMulti("Aesthetics"),
    "Narling Form": "",
    Mernara: "",
    Humanara: "",
    Transformation: "",
    "Alt form": ""
  };

  try {
    const res = await fetch(SUMMONS_URL, {
      method: "POST",
      body: new URLSearchParams(payload)
    });
    const result = await res.json();

    if (result.success) {
      statusMsg.textContent = "✅ Nara submitted successfully!";
      form.reset();

      // 🧹 Clear image preview
      const previewContainer = document.getElementById("imagePreviewContainer");
      const previewImg = document.getElementById("imagePreview");
      previewContainer.style.display = "none";
      previewImg.src = "";
      uploadStatus.textContent = "";
    } else {
      statusMsg.textContent = "❌ Error: " + result.error;
    }
  } catch (err) {
    console.error(err);
    statusMsg.textContent = "❌ Summon failed: " + err.message;
  }
}
